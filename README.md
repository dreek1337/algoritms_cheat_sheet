# Grokking Algorithms / Грокаем Алгоритмы

This repository contains the examples and algorithms written in Python for the book "Grokking Algorithms" by Aditya Bhargava with Russian and English comments.


## Contents

1. Binary Search.
2. Selection sort.
3. Countdown using recursion.
4. Printing greetings.
5. Factorial using recursion.
6. Sum of elements using recursion.
7. Counting elements using recursion.
8. Finding the greatest element using recursion.
9. Binary search using recursion.
10. Quick sort using recursion.
11. Voting using hash tables (dictionaries).
12. Breadth-first search using hash tables (dictionaries) and deques.
13. Dijkstra's algorithm using hash tables (dictionaries).
14. Greedy algorithm using sets and hash tables (dictionaries).

----
Этот репозиторий содержит примеры кода и алгоритмы на языке Python из книги "Грокаем Алгоритмы" Адитья Бхаргава с английскими и русскими комментариями.


## Содержание

1. Бинарный поиск.
2. Сортировка выбором.
3. Обратный отсчет, используя рекурсию.
4. Вывод приветствия.
5. Факториал, используя рекурсию.
6. Сумма элементов, используя рекурсию.
7. Подсчет элементов, используя рекурсию.
8. Поиск наибольшего элемента, используя рекурсию.
9. Бинарный поиск, используя рекурсию.
10. Быстрая сортировка, используя рекурсию.
11. Голосование, используя хеш-таблицы (словари).
12. Поиск в ширину, используя хеш-таблицы (словари) и двусторонние очереди.
13. Алгоритм Дейкстры, используя хеш-таблицы (словари).
14. Жадный алгоритм, используя множества и хеш-таблицы (словари).

## Краткий конспект

1. Алгоритм - инструкция для выполнения какой-либо задачи.
2. О-большое - означает сложность алгоритма. Описывает, насколько быстро работает алгоритм. А точнее, насколько быстро
возрастает время выполнения алгоритма. Позволяет сравнивать количество операций. Показывает, что алгоритм никогда не
будет работать хуже значения O(значение).
3. Линейный поиск имеет О(n) - занимает линейное время
4. В связанном списке, каждый элемент хранит адрес последующего элемента. Таким образом набор элементов объединяется в 
цепочку. Что позволяет размещать элементы в памяти в разброс, а не по порядку, где есть свободное место для элемента.
Связанные списки отлично подходят в тех случаях, когда вам необходимо проходить по каждому элементу последовательно, так
как перескакивать с элемента на произвольное расстояние сложно, из-за особенности хранения адреса следующего элемента.
5. В массиве обращение к произвольному элементу по индексу происходит мгновенно.
6. Скорость чтения: В массив - О(1), в связанный список О(n), скорость вставки в массиве О(n), в связанном списке О(1).
Удаление: в массиве О(n), в связанном списке О(1).
7. Сортировка выбором имеет скорость O(n * n) или O(n ^ 2).
8. Стек - список вызовов. В него каждый раз передаются новые элементы, они становятся первыми для вызова и самый 
последний добавленный элемент будет возвращен, если выполняются необходимые условия.
9. Быстрая сортировка имеет скорость О(n * log n).
10. У О-большого имеется константа, которая обычно игнорируется и выглядит выражение так О(с * n), где с - это
промежуток, между выполнением действия.
11. Хеш-таблица это структура данных, в которой реализована хеш-функция и массив. Хеш-функция связывает элемент
с индексом массива, в массив помещает значение, на нужный индекс, который соответствует значению, и при запросе 
со скоростью О(1) возвращает значение.
12. Граф - структура данных, используются для моделирования связей между объектами. Имеет узлы и ребра. Узлы могут быть
соединены друг с другом с помощью ребер, и такие узлы называются соседями. Одним из популярных алгоритмов работы с 
графом является поиск в ширину. Он применяется для поиска кратчайшего пути до цели.
13. Основные вопросы которые решает поиск в ширину: 1. Есть ли путь от узла А к узлу Б. 2. Как выглядит кратчайший путь
от А к Б.
14. Чем выше уровень связи, тем он менее предпочтителен. (Например: Поиск среди своих друзей - 1-й уровень, поиск среди
их друзей - 2-й уровень и т.д.) Поэтому поиск во втором уровне не должен производиться, пока вы не проверите всех на
первом.
15. Очередь - структура данных, в которой выполняется всего две операции: постановка в очередь и удаление из очереди. 
Используется в поиске в ширину, чем-то похоже на стек, нельзя обращаться к произвольным объектам в очереди. относится к 
категории структур FIFO: First In, First Out. А стек к LIFO: Last In, Last Out.